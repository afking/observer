
func (m *Map) tryCommit() {
	if !atomic.CompareAndSwapInt32(m.writeN, 0, -1) {
		//fmt.Println("busy!")
		return // busy
	}

	/*wN := (*int32)(atomic.LoadPointer(&m.writeN))
	if wN == nil {
		fmt.Println("init")
		return // init
	}

	if !atomic.CompareAndSwapInt32(wN, 0, -1) {
		//fmt.Println("busy!")
		return // busy
	}*/
	// n == -1
	//for !atomic.CompareAndSwapUintptr(&m.lock, 0, 1) {
	//	return // busy
	//	//runtime.Gosched()
	//}

	var i int
	v := m.write.v.Range(func(val interface{}) bool {
		if i != 0 { // ignore sentinel
			//fmt.Println("writing", val)
			val.(entry).writeTo(m.write.m)
		}
		i++
		return i < (64 + m.total)
	})
	m.write.v = v
	m.total = i

	rN := (*int32)(atomic.LoadPointer(&m.readN))
	atomic.AddInt32(rN, 1)

	// Swap
	m.write = (*store)(atomic.SwapPointer(&m.read, unsafe.Pointer(m.write)))
	m.writeN = (*int32)(atomic.SwapPointer(&m.readN, unsafe.Pointer(m.writeN)))

	atomic.StoreUintptr(&m.lock, 0)

	//fmt.Printf("tryCommit %d %+v\n", i, v)

	/*rN := (*int32)(atomic.LoadPointer(&m.readN))
	atomic.AddInt32(rN, 1)
	atomic.StorePointer(&m.writeN, unsafe.Pointer(rN))
	atomic.StorePointer(&m.readN, unsafe.Pointer(wN))
	m.write = (*store)(atomic.SwapPointer(&m.read, unsafe.Pointer(m.write)))
	// ^^^
	atomic.AddInt32(wN, 1)
	atomic.AddInt32(rN, -1)*/

	/*
		// Swap
		//*m.writeN++ // release
		//n := (*int32)(atomic.SwapPointer(&m.readN, unsafe.Pointer(m.writeN)))
		rN := atomic.SwapPointer(&m.readN, unsafe.Pointer(n))
		m.write = (*store)(atomic.SwapPointer(&m.read, unsafe.Pointer(m.write)))
		atomic.
			//atomic.Swap

			// Release TODO: race maaaybe?
			atomic.AddInt32((*int32)(atomic.LoadPointer(&m.readN)), 1)*/
}
